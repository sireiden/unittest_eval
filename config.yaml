models:
  - "gemma2:2b"
  - "granite-code:3b"
  - "qwen2.5-coder:3b"
  - "llama3.2:3b"

temperature: 0.2
max_length: 512

source_files:
  - "src/simple.py"
  - "src/intermediate.py"
  - "src/advanced.py"

evaluation:
  coverage_threshold: 50

strategy:
  - "Few-Shot"
  - "Chain of Thought"
  - "Self Consistency"

prompts:
  - name: spec_cross_check
    instruction: |
      Create pytest tests for <<CODE>> then:
      1. Generate a specification table mapping requirements to test cases
      2. Cross-verify each test against 3 codebase invariants
      3. Add validation comments showing spec-test alignment
      4. Flag any test/spec mismatches with pytest.fail(reason)

  - name: round_trip_verification
    instruction: |
      First write tests for <<CODE>>, then:
      1. Reverse-engineer requirements from the tests
      2. Generate new tests from derived requirements
      3. Compare original/reverse-engineered test suites
      4. Create consistency report using pytest-diff

  - name: conflict_detection
    instruction: |
      Create 5 test variants for <<CODE>>, then:
      1. Identify conflicting assumptions between tests
      2. Add @pytest.mark.parametrize merging valid cases
      3. Generate conflict matrix showing pairwise compatibility
      4. Verify mutual exclusivity with hypothesis plugin

  - name: version_consistency
    instruction: |
      Write tests for <<CODE>> including:
      1. @pytest.mark.parametrize with current/previous versions
      2. Semantic version compatibility checks
      3. Backward compatibility assertions
      4. Generate version drift report using pytest-html

  - name: coverage_validation
    instruction: |
      Create test suite then:
      1. Generate coverage heatmap with pytest-cov
      2. Write compensating tests for low-coverage areas
      3. Verify coverage consistency across 3 runs
      4. Add coverage threshold assertions

  - name: golden_master
    instruction: |
      For <<CODE>>:
      1. Create golden master test with known-good outputs
      2. Generate 5 mutated test variants
      3. Run differential consistency checks
      4. Add SHA-256 hash verification of results

  - name: multi_impl_check
    instruction: |
      Test <<CODE>> against:
      1. 3 alternative implementations
      2. Reference results comparison
      3. Statistical consistency checks
      4. Add @pytest.mark.parametrize impl matrix

  - name: invariant_checks
    instruction: |
      Create tests that:
      1. Document 5 core invariants in docstrings
      2. Verify invariant preservation
      3. Generate invariant violation scenarios
      4. Add property-based testing with hypothesis

  - name: id_consistency
    instruction: |
      Develop tests with:
      1. Structured test ID convention
      2. Automated ID format validation
      3. Namespaced parametrized IDs
      4. Add pytest --collect-only consistency check

  - name: change_impact
    instruction: |
      For <<CODE>>:
      1. Generate baseline test results
      2. Create code mutation variants
      3. Run differential impact analysis
      4. Add @pytest.mark.flaky for change detection

  - name: input_mutation
    instruction: |
      Create tests that:
      1. Generate original inputs
      2. Apply 3 mutation strategies
      3. Verify output consistency
      4. Add fuzzing with pytest-fuzz

  - name: temporal_consistency
    instruction: |
      Design tests that:
      1. Run in shuffled order 5 times
      2. Check for temporal dependencies
      3. Add @pytest.mark.repeat(10)
      4. Verify stateless consistency

  - name: schema_validation
    instruction: |
      For <<CODE>> outputs:
      1. Generate JSON Schema
      2. Create schema compliance tests
      3. Add @pytest.mark.parametrize edge cases
      4. Verify schema-test bidirectional consistency

  - name: parametrization_audit
    instruction: |
      Review test parameters:
      1. Create input space map
      2. Verify partition completeness
      3. Add missing boundary cases
      4. Generate parameter coverage report

  - name: exception_consistency
    instruction: |
      Test error handling:
      1. Catalog exception hierarchy
      2. Verify error type propagation
      3. Check message template consistency
      4. Add @pytest.mark.parametrize error chain

  - name: resource_consistency
    instruction: |
      For resource-heavy tests:
      1. Track file handles/memory usage
      2. Add leak detection fixtures
      3. Verify pre/post state equivalence
      4. Generate resource audit report

  - name: doc_consistency
    instruction: |
      Align tests with docs:
      1. Parse function docstrings
      2. Generate test cases from examples
      3. Verify test-doc consistency
      4. Add doctest comparison with pytest --doctest-modules

  - name: perf_consistency
    instruction: |
      Validate performance:
      1. Establish baseline metrics
      2. Run statistical consistency checks
      3. Add CI/CD performance gates
      4. Generate pytest-benchmark histograms

  - name: security_consistency
    instruction: |
      Security test validation:
      1. Replay historical vulnerabilities
      2. Verify remediation persistence
      3. Add OWASP consistency checks
      4. Generate attack matrix report

  - name: boundary_consistency
    instruction: |
      Audit boundary handling:
      1. Map declared vs tested boundaries
      2. Generate out-of-bound test cases
      3. Verify error consistency
      4. Add @pytest.mark.parametrize overflow checks
